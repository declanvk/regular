var searchIndex = JSON.parse('{\
"regular":{"doc":"Tools for manipulating regular languages.","i":[[0,"accept","regular","Generalization of the accept/non-accept of regular …",null,null],[8,"Accept","regular::accept","Trait for objects that can decide whether or not a string …",null,null],[16,"Symbol","","The type of symbols in the strings.",0,null],[10,"accept","","Return <code>true</code> if the given string is member of the language …",0,[[["intoiterator",8]]]],[8,"IterExt","","Extension to the <code>Iterator</code> trait to test whether the …",null,null],[11,"is_accepted","","Return <code>true</code> if the string given by this iterator is a …",1,[[["accept",8]]]],[0,"alphabet","regular","Traits and implementations of generic sets of symbol, …",null,null],[8,"Alphabet","regular::alphabet","A set of symbols.",null,null],[16,"Symbol","","The type of elements in this set.",2,null],[16,"ValueIter","","An iterator over all values in this alphabet.",2,null],[10,"values","","Return an iterator over all value in this alphabet.",2,[[]]],[10,"contains","","Return <code>true</code> if the given symbol is a member of this …",2,[[]]],[10,"num_values","","Optionally return the number of elements in this …",2,[[],["option",4]]],[3,"Boolean","","Alphabet containing all booleans {True, False}.",null,null],[3,"Unit","","Alphabet containing single symbol of the unit type.",null,null],[8,"IntoAlphabet","","Coversion into an alphabet.",null,null],[16,"Symbol","","The type of symbols in the alphabet.",3,null],[16,"IntoAlpha","","The type of alphabet we are turning this into.",3,null],[10,"into_alphabet","","Create an alphabet from this value.",3,[[]]],[3,"FullRange","","An object which can be turned into an alphabet which has …",null,null],[0,"prelude","regular","Common items to import.",null,null],[3,"DFABuilder","regular::prelude","Builder for a DFA.",null,null],[8,"DFAStorage","","Backend for the DFA struct.",null,null],[16,"State","","Type representing a state of the DFA.",4,null],[10,"from_alphabet","","Construct a new instance of this storage from the …",4,[[]]],[10,"alphabet","","Return a reference to the alphabet used by this DFA.",4,[[]]],[10,"all_states","","Return a list of all the valid states of this DFA.",4,[[],["vec",3]]],[10,"all_transitions","","Return a list of all transitions of this DFA.",4,[[],["vec",3]]],[10,"contains_state","","Return <code>true</code> if the given state is valid in this DFA.",4,[[]]],[10,"transition","","Return <code>Some(end)</code> if there exists a transition from <code>current</code>…",4,[[],["option",4]]],[11,"transition_unchecked","","Return the resulting state from transitioning from the …",4,[[]]],[10,"add_state","","Return a new unique state.",4,[[]]],[10,"add_transition","","Record the given transition.",4,[[]]],[3,"DefaultDFAStorage","","Default storage for a DFA.",null,null],[3,"DFA","","A deterministic finite automaton.",null,null],[4,"Error","","Errors from <code>regular</code> operations.",null,null],[13,"MissingStartState","","Start state was not specified.",5,null],[13,"InvalidState","","State specified was not valid for this automaton.",5,null],[13,"SymbolNotInAlphabet","","Symbol not found in alphabet.",5,null],[13,"StateNotFound","","State not found.",5,null],[13,"OperationWithNonEqualAlphabets","","Attempted to perform operation with two different …",5,null],[3,"DFABuilder","regular","Builder for a DFA.",null,null],[8,"DFAStorage","","Backend for the DFA struct.",null,null],[16,"State","","Type representing a state of the DFA.",4,null],[10,"from_alphabet","","Construct a new instance of this storage from the …",4,[[]]],[10,"alphabet","","Return a reference to the alphabet used by this DFA.",4,[[]]],[10,"all_states","","Return a list of all the valid states of this DFA.",4,[[],["vec",3]]],[10,"all_transitions","","Return a list of all transitions of this DFA.",4,[[],["vec",3]]],[10,"contains_state","","Return <code>true</code> if the given state is valid in this DFA.",4,[[]]],[10,"transition","","Return <code>Some(end)</code> if there exists a transition from <code>current</code>…",4,[[],["option",4]]],[11,"transition_unchecked","regular::prelude","Return the resulting state from transitioning from the …",4,[[]]],[10,"add_state","regular","Return a new unique state.",4,[[]]],[10,"add_transition","","Record the given transition.",4,[[]]],[3,"DefaultDFAStorage","","Default storage for a DFA.",null,null],[3,"DFA","","A deterministic finite automaton.",null,null],[4,"Error","","Errors from <code>regular</code> operations.",null,null],[13,"MissingStartState","","Start state was not specified.",5,null],[13,"InvalidState","","State specified was not valid for this automaton.",5,null],[13,"SymbolNotInAlphabet","","Symbol not found in alphabet.",5,null],[13,"StateNotFound","","State not found.",5,null],[13,"OperationWithNonEqualAlphabets","","Attempted to perform operation with two different …",5,null],[4,"Range","","Set of contiguous elements",null,null],[13,"NonEmpty","","Non-empty range",6,null],[12,"start","regular::Range","Start value, inclusive",7,null],[12,"end","","End value, inclusive",7,null],[13,"Empty","regular","Empty range",6,null],[11,"into_alphabet","regular::alphabet","",8,[[]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"into_alphabet","","",9,[[]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","regular::prelude","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"to_string","","",5,[[],["string",3]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"into_alphabet","regular","",6,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"into_iter","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"values","","",6,[[]]],[11,"contains","","",6,[[]]],[11,"num_values","","",6,[[],["option",4]]],[11,"values","regular::alphabet","",8,[[]]],[11,"contains","","",8,[[]]],[11,"num_values","","",8,[[],["option",4]]],[11,"values","","",9,[[]]],[11,"contains","","",9,[[]]],[11,"num_values","","",9,[[],["option",4]]],[11,"into_alphabet","","",10,[[]]],[11,"from_alphabet","regular::prelude","",12,[[]]],[11,"all_states","","",12,[[],["vec",3]]],[11,"all_transitions","","",12,[[],["vec",3]]],[11,"transition","","",12,[[],["option",4]]],[11,"add_state","","",12,[[]]],[11,"add_transition","","",12,[[]]],[11,"contains_state","","",12,[[]]],[11,"alphabet","","",12,[[]]],[11,"next","regular","",6,[[],["option",4]]],[11,"clone","regular::alphabet","",8,[[],["boolean",3]]],[11,"clone","","",9,[[],["unit",3]]],[11,"clone","regular::prelude","",11,[[],["dfa",3]]],[11,"clone","","",12,[[],["defaultdfastorage",3]]],[11,"clone","","",13,[[],["dfabuilder",3]]],[11,"clone","","",5,[[],["error",4]]],[11,"clone","regular","",6,[[],["range",4]]],[11,"eq","regular::alphabet","",8,[[["boolean",3]]]],[11,"eq","","",9,[[["unit",3]]]],[11,"eq","regular","",6,[[["range",4]]]],[11,"ne","","",6,[[["range",4]]]],[11,"fmt","regular::alphabet","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","regular::prelude","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","regular","",6,[[["formatter",3]],["result",6]]],[11,"fmt","regular::prelude","",5,[[["formatter",3]],["result",6]]],[11,"hash","regular::alphabet","",8,[[]]],[11,"hash","","",9,[[]]],[11,"hash","regular","",6,[[]]],[11,"intersection","regular::prelude","Construct a new DFA that accepts the regular language …",11,[[["dfa",3]],[["error",4],["result",4],["dfa",3]]]],[11,"union","","Construct a new DFA that accepts the regular language …",11,[[["dfa",3]],[["error",4],["result",4],["dfa",3]]]],[11,"difference","","Construct a new DFA that accepts the regular language …",11,[[["dfa",3]],[["error",4],["result",4],["dfa",3]]]],[11,"complement","","Construct a new DFA that accepts the regular language …",11,[[]]],[11,"transition_unchecked","","Return the resulting state from transitioning from the …",4,[[]]],[11,"accept_states","","The states of DFA that will cause it to accept a string.",11,[[]]],[11,"dead_state","","An optional state that signals early termination of the …",11,[[],["option",4]]],[11,"start_state","","The starting state of the DFA.",11,[[]]],[11,"into_builder","","Convert this DFA back into the DFABuilder form.",11,[[],["dfabuilder",3]]],[11,"accept","","Accept or reject a string based on the content of this …",11,[[["intoiterator",8]]]],[11,"accept_unchecked","","Accept or reject a string based on the content of this …",11,[[["intoiterator",8]]]],[11,"new","","Construct a new default storage with the given alphabet.",12,[[]]],[11,"new","","Create a new DFABuilder with the given alphabet.",13,[[["intoalphabet",8]]]],[11,"new_with_storage","","Create a new DFABuilder with a customer storage backend.",13,[[]]],[11,"storage","","Return a reference to the <code>DFAStorage</code> backing this builder.",13,[[]]],[11,"alphabet","","Return a reference to the <code>Alphabet</code> in the storage of this …",13,[[]]],[11,"new_state","","Record and return a new state.",13,[[]]],[11,"transition","","Record and validate a new transition.",13,[[],[["result",4],["error",4]]]],[11,"transitions","","Record and validate multiple transitions.",13,[[],[["result",4],["error",4]]]],[11,"accept_states","","Add to the set of accept states.",13,[[]]],[11,"start_state","","Set the starting state.",13,[[]]],[11,"dead_state","","Set the dead/error state.",13,[[["option",4]]]],[11,"build","","Build the DFA",13,[[],[["dfa",3],["result",4],["error",4]]]],[11,"contains","regular","Returns <code>true</code> if the given elements is within the range.",6,[[]]]],"p":[[8,"Accept"],[8,"IterExt"],[8,"Alphabet"],[8,"IntoAlphabet"],[8,"DFAStorage"],[4,"Error"],[4,"Range"],[13,"NonEmpty"],[3,"Boolean"],[3,"Unit"],[3,"FullRange"],[3,"DFA"],[3,"DefaultDFAStorage"],[3,"DFABuilder"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);