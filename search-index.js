var searchIndex = JSON.parse('{\
"regular":{"doc":"Tools for manipulating regular languages.","t":[3,3,8,3,13,4,13,13,13,13,4,16,13,13,0,10,10,10,10,0,10,11,11,11,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,0,11,10,11,11,11,11,12,12,8,8,16,10,11,8,3,3,16,8,16,16,3,16,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,2,3,3,8,3,4,13,2,13,13,16,13,13,11,11,11,11,11,10,11,10,11,10,11,10,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["DFA","DFABuilder","DFAStorage","DefaultDFAStorage","Empty","Error","InvalidState","MissingStartState","NonEmpty","OperationWithNonEqualAlphabets","Range","State","StateNotFound","SymbolNotInAlphabet","accept","add_state","add_transition","all_states","all_transitions","alphabet","alphabet","borrow","borrow_mut","clone","clone_into","contains","contains","contains_state","eq","fmt","from","from_alphabet","hash","into","into_alphabet","into_iter","ne","next","num_values","prelude","to_owned","transition","try_from","try_into","type_id","values","end","start","Accept","IterExt","Symbol","accept","is_accepted","Alphabet","Boolean","FullRange","IntoAlpha","IntoAlphabet","Symbol","Symbol","Unit","ValueIter","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","contains","contains","contains","eq","eq","fmt","fmt","fmt","from","from","from","hash","hash","into","into","into","into_alphabet","into_alphabet","into_alphabet","into_alphabet","num_values","num_values","num_values","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","values","values","values","Accept","DFA","DFABuilder","DFAStorage","DefaultDFAStorage","Error","InvalidState","IterExt","MissingStartState","OperationWithNonEqualAlphabets","State","StateNotFound","SymbolNotInAlphabet","accept","accept","accept_states","accept_states","accept_unchecked","add_state","add_state","add_transition","add_transition","all_states","all_states","all_transitions","all_transitions","alphabet","alphabet","alphabet","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","build","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","complement","contains_state","contains_state","dead_state","dead_state","difference","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from_alphabet","from_alphabet","intersection","into","into","into","into","into_builder","new","new","new_state","new_with_storage","start_state","start_state","storage","to_owned","to_owned","to_owned","to_owned","to_string","transition","transition","transition","transition_unchecked","transition_unchecked","transition_unchecked","transitions","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","union"],"q":["regular","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","regular::Range","","regular::accept","","","","","regular::alphabet","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","regular::prelude","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["A deterministic finite automaton.","Builder for a DFA.","Backend for the DFA struct.","Default storage for a DFA.","Empty range","Errors from <code>regular</code> operations.","State specified was not valid for this automaton.","Start state was not specified.","Non-empty range","Attempted to perform operation with two different …","Set of contiguous elements","Type representing a state of the DFA.","State not found.","Symbol not found in alphabet.","Generalization of the accept/non-accept of regular …","Return a new unique state.","Record the given transition.","Return a list of all the valid states of this DFA.","Return a list of all transitions of this DFA.","Traits and implementations of generic sets of symbol, …","Return a reference to the alphabet used by this DFA.","","","","","","Returns <code>true</code> if the given elements is within the range.","Return <code>true</code> if the given state is valid in this DFA.","","","Returns the argument unchanged.","Construct a new instance of this storage from the provided …","","Calls <code>U::from(self)</code>.","","","","","","Common items to import.","","Return <code>Some(end)</code> if there exists a transition from <code>current</code> …","","","","","End value, inclusive","Start value, inclusive","Trait for objects that can decide whether or not a string …","Extension to the <code>Iterator</code> trait to test whether the …","The type of symbols in the strings.","Return <code>true</code> if the given string is member of the language …","Return <code>true</code> if the string given by this iterator is a …","A set of symbols.","Alphabet containing all booleans {True, False}.","An object which can be turned into an alphabet which has …","The type of alphabet we are turning this into.","Coversion into an alphabet.","The type of elements in this set.","The type of symbols in the alphabet.","Alphabet containing single symbol of the unit type.","An iterator over all values in this alphabet.","","","","","","","","","","","Return <code>true</code> if the given symbol is a member of this …","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Create an alphabet from this value.","","","","Optionally return the number of elements in this alphabet. …","","","","","","","","","","","","","","Return an iterator over all value in this alphabet.","","","","A deterministic finite automaton.","Builder for a DFA.","Backend for the DFA struct.","Default storage for a DFA.","Errors from <code>regular</code> operations.","State specified was not valid for this automaton.","","Start state was not specified.","Attempted to perform operation with two different …","Type representing a state of the DFA.","State not found.","Symbol not found in alphabet.","Accept or reject a string based on the content of this DFA.","","The states of DFA that will cause it to accept a string.","Add to the set of accept states.","Accept or reject a string based on the content of this …","Return a new unique state.","","Record the given transition.","","Return a list of all the valid states of this DFA.","","Return a list of all transitions of this DFA.","","Return a reference to the alphabet used by this DFA.","","Return a reference to the <code>Alphabet</code> in the storage of this …","","","","","","","","","Build the DFA","","","","","","","","","Construct a new DFA that accepts the regular language that …","Return <code>true</code> if the given state is valid in this DFA.","","An optional state that signals early termination of the …","Set the dead/error state.","Construct a new DFA that accepts the regular language that …","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Construct a new instance of this storage from the provided …","","Construct a new DFA that accepts the regular language that …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Convert this DFA back into the DFABuilder form.","Construct a new default storage with the given alphabet.","Create a new DFABuilder with the given alphabet.","Record and return a new state.","Create a new DFABuilder with a customer storage backend.","The starting state of the DFA.","Set the starting state.","Return a reference to the <code>DFAStorage</code> backing this builder.","","","","","","Return <code>Some(end)</code> if there exists a transition from <code>current</code> …","","Record and validate a new transition.","Return the resulting state from transitioning from the …","Return the resulting state from transitioning from the …","Return the resulting state from transitioning from the …","Record and validate multiple transitions.","","","","","","","","","","","","","Construct a new DFA that accepts the regular language that …"],"i":[0,0,0,0,1,0,2,2,1,2,0,3,2,2,0,3,3,3,3,0,3,1,1,1,1,1,1,3,1,1,1,3,1,1,1,1,1,1,1,0,1,3,1,1,1,1,4,4,0,0,5,5,6,0,0,0,7,0,8,7,0,8,9,10,11,9,10,11,9,10,9,10,8,9,10,9,10,9,10,11,9,10,11,9,10,9,10,11,7,9,10,11,8,9,10,9,10,9,10,11,9,10,11,9,10,11,8,9,10,0,0,0,0,0,0,2,0,2,2,3,2,2,12,12,12,13,12,3,14,3,14,3,14,3,14,3,14,13,12,14,13,2,12,14,13,2,13,12,14,13,2,12,14,13,2,12,3,14,12,13,12,12,14,13,2,2,12,14,13,2,3,14,12,12,14,13,2,12,14,13,13,13,12,13,13,12,14,13,2,2,3,14,13,3,3,3,13,12,14,13,2,12,14,13,2,12,14,13,2,12],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["",0]]],[[["",0]]],[[["",0]],["vec",3]],[[["",0]],["vec",3]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["range",4,[["",26,[["clone",8],["step",8]]]]]],["range",4,[["",26,[["clone",8],["step",8]]]]]],[[["",0],["",0]]],[[["range",4]],["bool",0]],[[["range",4]],["bool",0]],[[["",0]],["bool",0]],[[["range",4,[["",26,[["partialeq",8],["step",8]]]]],["range",4]],["bool",0]],[[["range",4,[["",26,[["debug",8],["step",8]]]]],["formatter",3]],["result",6]],[[]],[[]],[[["range",4,[["",26,[["hash",8],["step",8]]]]],["",0]]],[[]],[[]],[[]],[[["range",4,[["",26,[["partialeq",8],["step",8]]]]],["range",4]],["bool",0]],[[["range",4]],["option",4]],[[["range",4]],["option",4,[["usize",0]]]],null,[[["",0]]],[[["",0]],["option",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["range",4]]],null,null,null,null,null,[[["intoiterator",8]],["bool",0]],[[["accept",8]],["bool",0]],null,null,null,null,null,null,null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["boolean",3]],["boolean",3]],[[["unit",3]],["unit",3]],[[["",0],["",0]]],[[["",0],["",0]]],[[["",0]],["bool",0]],[[["boolean",3]],["bool",0]],[[["unit",3]],["bool",0]],[[["boolean",3],["boolean",3]],["bool",0]],[[["unit",3],["unit",3]],["bool",0]],[[["boolean",3],["formatter",3]],["result",6]],[[["unit",3],["formatter",3]],["result",6]],[[["fullrange",3,[["",26,[["debug",8],["step",8]]]]],["formatter",3]],["result",6]],[[]],[[]],[[]],[[["boolean",3],["",0]]],[[["unit",3],["",0]]],[[]],[[]],[[]],[[]],[[]],[[]],[[["fullrange",3]]],[[["",0]],["option",4,[["usize",0]]]],[[["boolean",3]],["option",4,[["usize",0]]]],[[["unit",3]],["option",4,[["usize",0]]]],[[["",0]]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]]],[[["boolean",3]]],[[["unit",3]]],null,null,null,null,null,null,null,null,null,null,null,null,null,[[["dfa",3],["intoiterator",8]],["bool",0]],[[["dfa",3],["intoiterator",8]],["bool",0]],[[["dfa",3]]],[[["dfabuilder",3],["intoiterator",8]],["dfabuilder",3]],[[["dfa",3],["intoiterator",8]],["bool",0]],[[["",0]]],[[["defaultdfastorage",3]]],[[["",0]]],[[["defaultdfastorage",3]]],[[["",0]],["vec",3]],[[["defaultdfastorage",3]],["vec",3]],[[["",0]],["vec",3]],[[["defaultdfastorage",3]],["vec",3]],[[["",0]],["",0]],[[["defaultdfastorage",3]],["",0]],[[["dfabuilder",3]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["dfabuilder",3]],["result",4,[["dfa",3],["error",4]]]],[[["dfa",3,[["",26,[["clone",8],["alphabet",8]]],["",26,[["clone",8],["dfastorage",8,[["",26,[["clone",8],["alphabet",8]]]]]]]]]],["dfa",3,[["",26,[["clone",8],["alphabet",8]]],["",26,[["clone",8],["dfastorage",8,[["",26,[["clone",8],["alphabet",8]]]]]]]]]],[[["defaultdfastorage",3,[["clone",8],["",26,[["clone",8],["eq",8],["hash",8]]]]]],["defaultdfastorage",3,[["clone",8],["",26,[["clone",8],["eq",8],["hash",8]]]]]],[[["dfabuilder",3,[["",26,[["clone",8],["alphabet",8]]],["",26,[["clone",8],["dfastorage",8,[["",26,[["clone",8],["alphabet",8]]]]]]]]]],["dfabuilder",3,[["",26,[["clone",8],["alphabet",8]]],["",26,[["clone",8],["dfastorage",8,[["",26,[["clone",8],["alphabet",8]]]]]]]]]],[[["error",4]],["error",4]],[[["",0],["",0]]],[[["",0],["",0]]],[[["",0],["",0]]],[[["",0],["",0]]],[[["dfa",3]],["dfa",3]],[[["",0]],["bool",0]],[[["defaultdfastorage",3]],["bool",0]],[[["dfa",3]],["option",4]],[[["dfabuilder",3],["option",4]],["dfabuilder",3]],[[["dfa",3],["dfa",3]],["result",4,[["dfa",3],["error",4]]]],[[["dfa",3,[["",26,[["debug",8],["alphabet",8]]],["",26,[["debug",8],["dfastorage",8,[["",26,[["debug",8],["alphabet",8]]]]]]]]],["formatter",3]],["result",6]],[[["defaultdfastorage",3,[["debug",8],["",26,[["debug",8],["eq",8],["hash",8]]]]],["formatter",3]],["result",6]],[[["dfabuilder",3,[["",26,[["debug",8],["alphabet",8]]],["",26,[["debug",8],["dfastorage",8,[["",26,[["debug",8],["alphabet",8]]]]]]]]],["formatter",3]],["result",6]],[[["error",4],["formatter",3]],["result",6]],[[["error",4],["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[],["defaultdfastorage",3]],[[["dfa",3],["dfa",3]],["result",4,[["dfa",3],["error",4]]]],[[]],[[]],[[]],[[]],[[["dfa",3]],["dfabuilder",3]],[[],["defaultdfastorage",3]],[[["intoalphabet",8]],["dfabuilder",3]],[[["dfabuilder",3]]],[[],["dfabuilder",3]],[[["dfa",3]]],[[["dfabuilder",3]],["dfabuilder",3]],[[["dfabuilder",3]],["",0]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0]],["string",3]],[[["",0]],["option",4]],[[["defaultdfastorage",3]],["option",4]],[[["dfabuilder",3]],["result",4,[["error",4]]]],[[["",0]]],[[["",0]]],[[["",0]]],[[["dfabuilder",3],["intoiterator",8]],["result",4,[["error",4]]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["dfa",3],["dfa",3]],["result",4,[["dfa",3],["error",4]]]]],"p":[[4,"Range"],[4,"Error"],[8,"DFAStorage"],[13,"NonEmpty"],[8,"Accept"],[8,"IterExt"],[8,"IntoAlphabet"],[8,"Alphabet"],[3,"Boolean"],[3,"Unit"],[3,"FullRange"],[3,"DFA"],[3,"DFABuilder"],[3,"DefaultDFAStorage"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
